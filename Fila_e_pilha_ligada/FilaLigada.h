#ifndef FILALIGADA_H_INCLUDED
#define FILALIGADA_H_INCLUDED
#include "Node.h"

                                    //FILA SE CARACTERIZA POR PEPS
                                    //LIGADA POR PONTEIROS(NÃO É UMA ALOCAÇÃO SEQUENCIAL NA MEMONORIA),
                                    //COM ELA NÃO É NECESSARIO RESERVAR ESPAÇO NA MEMORIA SENDO ASSIM ELE SALVA ENQUANTO HOUVER ESPAÇO NA MEMORIA,
                                    //DE FORMA ALEATORIA, QM SALVA O ENDEREÇO É O PONTEIRO
template <typename Tipo>
struct FilaLigada{
                                    //PONTEIRO PARA UMA ESTRUTURA NODE(UMA VARIAVEL CORINGA E UM PONTEIRO PARA UMA MESMA ESTRUTURA)
     Node<Tipo> * inicio;           //ESSE VAI APONTA PARA O INICO DA FILA
     Node<Tipo> * fim;              //ESSE VAI APONTA PARA O FINAL DA FILA
                                    //OU SEJA A OPERAÇÃO DE INSERÇÃO NA FILA É FEITA PELO PONTEIRO FIM
                                    //REMOÇÃO PELO PONTEIRO INICIO

    FilaLigada(){                   //CONSTRUTOR DA FILA OU SEJA QUANDO A FILA FOR ESTANCIADA AS VARIAVEIS QUE IRÃO SER INICIALIZADAS..
        inicio = NULL;              //COMO NÃO A VALOR NENHUM OS PONTEIROS SE INICIAL EM NULL
        fim = NULL;
    }

    bool filaVazia(){               //PRIMEIRO METODO VERIFICAR SE A FILA ESTA VAZIA
        return inicio==NULL;        //RETORNAR  TRUE SE PONTEIRO INICIO ESTIVER EM NULL
    }
                                    //INSERIR É BOOLEAN PQ RESPONDE A PERGUNTA "INSERIDO COM SUCESSO?"
    bool inserir(Tipo x) {          //RECEBE O VALO POR PARAMETRO PELA VARIAVEL CORINGA
        bool v = true;              //VARIAVEL(LOCAL) QUE VAI RETORNA PELO FUNCAO
        Node<Tipo> * aux = new Node<Tipo>;    //DECLARA UMA STRUCT(LOCAL) NODE E ATRIBUI OUTRA DENTRO DELA
        if(aux==NULL){              //SE AUX RETORNOU NULL, NAO CONSEGIU ESPAÇO NA MEMORIA
            v = false;              //ENTÃO VOLTA FALSE EM RESPOSTA A PERGUNTA
        }else{
            aux->info = x;          //A VARIAVEL CORINGA DENTRO DE AUX(STRUCT NODE), RECEBE O VALOR DE X(TBEM CORINGA "OU SEJA MESMO TIPO")
            aux->prox = NULL;       //O PONTEIRO DE ESTRUTURA NODE APONTA PARA NULL(ISSO EQUIVALE QUE ELE É O ULTIMO, POIS O PROXIMO VALOR É NULL)

                                    //TODA FILA COMEÇA, INICIO ESTA APONTANDO PARA NULL, COM A INSERÇÃO ELA TEM QUE APONTAR PARA ELE AGORA
            if(inicio==NULL){       //ENTÃO SE A FILA ESTIVER COMEÇANDO
                inicio = aux;       //O PONTEIRO INICIO VAI APONTAR PARA ONDE AUX ESTA APONTANDO

            }else{                  //SE NÃO
                fim->prox = aux;    //O PONTEIRO DENTRO DA ESTRUTURA NODE FIM (PROX),
                                    //QUE SERVE PARA APONTAR PARA A PROXIMA ESTRUTURA, RECEBE O ENDEREÇO DE MEMORIA DE AUX(PROXIMA ESTRUTURA)
            }
            fim=aux;                //FIM DEIXA DE APONTAR PARA A ESTRUTURA ANTERIOR E COMEÇA A APONTAR PARA AUX QUE É O NOVO FIM DA FILA
                                    //DE TODO MODO SE CONSEGIU ALOCAR (AUX!=NULL) FIM VAI APONTAR PRA AUX, POR ISSO ELE ESTA DENTRO DO PRIMEIRO IF
        }
                                    //POR ESSAS FUNÇAO DA PRA VER O "NO" SE FORMANDO A ESTRUTURA ANTERIOR APONTANDO PARA A PROXIMA
                                    //SENDO POSSIVEL CORRER SO PELO INICIO POIS ELE APONTA PARA A ESTRUTUTA QUE TEM O ENDEREÇO DA PROXIMA
                                    //FIM SEMPRE APONTA PARA NULL PARA INDICAR QUE É O ULTIMO VALOR INERIDO.
                                    //AO INISERIR UM VALOR PEGAMOS O PONTEIRO PROX DENTRO DO PONTEIRO FIM QUE ESTAVA APONTADO PARA NULL E
                                    //APONTAMOS PARA O ENDEREÇO DE MEMORIA DE AUX, APOS ISSO TAMBEM APONTAMOS FIM PARA AUX,
                                    //ASSIM O ANTIGO FIM FICA PRESO PELA ESTRUTURA QUE VEIO ANTES DELE, SÓ SENDO POSSIVEL O PEGAR POR MEIO DA ANTERIOR
                                    //POR ISSO INICIO FIXO APOS A PRIMEIRA INSERSÃO( INICIO->INFO "POSSUI O VALOR DO TIPO DE NODE", INICIO->PROX APONTA PARA A PROXIMA ESTRUTURA) E
                                    //(FIM É APONTADO PELA ESTRUTURA ANTERIOR EX"ANTEROR->INFO = INFORMAÇÃO ANTERIOR, ANTERIOR->PROX = FIM"
                                    // E FIM APONTA FIM->INFO= ULTIMA INFORMAÇÃO INSERIDA, FIM->NULL)

        return v;                   //RETORNA A RESPOSTA PARA A PERGUNTA TRUEL OU FALSE

    }

    Tipo primeiro(){                //RETORNA UMA VARIAVEL DO TIPO CORINGA
        return inicio->info;        //O VALOR QUE VAI SER RETORNADO É O VALOR DA INFORMAÇÃO QUE ESTA NO ENDEREÇO DE MEMORIA QUE INICIO ESTA APONTANDO
    }

    Tipo remover(){                 //VAI RETORNA A INFO QUE ESTA DENTRO DO PONTEIRO INICIO QUE VAI SER REMOVIDA

        Tipo temp = inicio->info;   //CRIA UMA VARIAVEL TIPO(CORINGA) E ATRIBUI O VALOR DE INFO(DENTRO DO PONTEIRO)

        Node<Tipo> * aux = new Node<Tipo>;    //CRIA UMA VARIAVEL DO TIPO NODE AUX E CRIA UM ESPAÇO NA MEMORIA PARA UMA ESTRUTURA NODE

        aux = inicio;               //ESSE ESPAÇO DA MEMORIA RECEBE O ENDEREÇO DE INICIO;

        inicio = inicio->prox;      //INICIO COMEÇA A APONTAR PARA A O ENDEREÇO DA PROXIMA ESTRUTURA QUE ESTAVA DENTRO DO PONTEIRO PROX DENTRO DELA

        if(inicio == NULL){         //SE INICIO FOR NULL SIGNIFICA QUE FIM TAMBEM ESTA APONTANDO PARA A ESTRUTURA QUE IRA SER REMOVIDA
            fim =NULL;              //ASSIM FIM TAMBEM DEVE SER NULL
        }
        delete aux;                 //AUZ RECEUBEU INCIO POR UM MOTIVO, PARA QUE A ESTRUTURA QUE IRIA SER DELETADA NÃO FICASE SOLTA NA MEMORIA,
                                    //PQ QM APONTAVA PARA O ENDEREÇO DE MEMORIA ERA INICIO QUE PASSOU A APONTAR O PROXIMO DA ESTRUTURA
                                    //AGORA AUX SERA "DELETADO", NA VDD DEVOLVENDO O ESPAÇO DA MEMORIA AO SISTEMA OPERACIONAL

        return temp;                //RETORNA A INFO QUE ESTAVA DENTRO DE INICIO ANTERIORMENTE.

    }
};

#endif // FILALIGADA_H_INCLUDED
